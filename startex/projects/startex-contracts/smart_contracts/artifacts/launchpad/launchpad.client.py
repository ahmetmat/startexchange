# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"name": "LaunchpadApp", "structs": {}, "methods": [{"name": "setup", "args": [{"type": "address", "name": "owner"}, {"type": "uint64", "name": "token_id"}], "returns": {"type": "void"}}, {"name": "set_sale_parameters", "args": [{"type": "uint64", "name": "price"}, {"type": "uint64", "name": "start_time"}, {"type": "uint64", "name": "end_time"}], "returns": {"type": "bool"}}, {"name": "activate_sale", "args": [], "returns": {"type": "bool"}}, {"name": "opt_in_to_asset", "args": [], "returns": {"type": "bool"}}, {"name": "fund", "args": [{"type": "axfer", "name": "axfer"}], "returns": {"type": "bool"}}, {"name": "buy_tokens", "args": [{"type": "pay", "name": "payment"}], "returns": {"type": "uint64"}}, {"name": "claim_funds", "args": [], "returns": {"type": "bool"}}], "state": {"global": {"num_uints": 6, "num_byte_slices": 1}, "local": {"num_uints": 0, "num_byte_slices": 0}}, "bare_actions": {"create": "CALL"}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or a dataclass for the respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetupArgs:
    """Dataclass for setup arguments"""
    owner: str
    token_id: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetSaleParametersArgs:
    """Dataclass for set_sale_parameters arguments"""
    price: int
    start_time: int
    end_time: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class FundArgs:
    """Dataclass for fund arguments"""
    axfer: algokit_utils.Transaction

@dataclasses.dataclass(frozen=True, kw_only=True)
class BuyTokensArgs:
    """Dataclass for buy_tokens arguments"""
    payment: algokit_utils.Transaction

class LaunchpadAppClient:
    """Client for interacting with LaunchpadApp smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...

    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")

    def setup(
        self,
        args: tuple[str, int] | SetupArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "setup",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def set_sale_parameters(
        self,
        args: tuple[int, int, int] | SetSaleParametersArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "set_sale_parameters",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def activate_sale(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        return self.app_client.call(
            "activate_sale",
            transaction_parameters=transaction_parameters,
        )

    def opt_in_to_asset(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        return self.app_client.call(
            "opt_in_to_asset",
            transaction_parameters=transaction_parameters,
        )

    def fund(
        self,
        args: tuple[algokit_utils.Transaction] | FundArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "fund",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def buy_tokens(
        self,
        args: tuple[algokit_utils.Transaction] | BuyTokensArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "buy_tokens",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def claim_funds(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        return self.app_client.call(
            "claim_funds",
            transaction_parameters=transaction_parameters,
        )

