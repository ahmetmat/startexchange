# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"name": "CompetitionApp", "structs": {"Competition": {"name": "Competition", "elements": [["name", "string"], ["description", "string"], ["start_time", "uint64"], ["end_time", "uint64"], ["status", "uint64"], ["total_prize_pool", "uint64"], ["max_participants", "uint64"], ["entry_fee", "uint64"]]}, "Participant": {"name": "Participant", "elements": [["startup_owner", "address"], ["joined_at", "uint64"], ["score", "uint64"], ["rank", "uint64"], ["reward_claimed", "bool"]]}, "Results": {"name": "Results", "elements": [["first_place_sid", "uint64"], ["second_place_sid", "uint64"], ["third_place_sid", "uint64"], ["rewards_distributed", "bool"]]}}, "methods": [{"name": "set_owner", "args": [{"type": "address", "name": "new_owner"}], "returns": {"type": "void"}}, {"name": "create_competition", "args": [{"type": "string", "name": "name"}, {"type": "string", "name": "description"}, {"type": "uint64", "name": "start_time"}, {"type": "uint64", "name": "end_time"}, {"type": "pay", "name": "prize_pool_payment"}, {"type": "uint64", "name": "max_participants"}, {"type": "uint64", "name": "entry_fee"}], "returns": {"type": "uint64"}}, {"name": "join_competition", "args": [{"type": "uint64", "name": "competition_id"}, {"type": "uint64", "name": "startup_id"}, {"type": "pay", "name": "entry_fee_payment"}], "returns": {"type": "bool"}}, {"name": "update_status", "args": [{"type": "uint64", "name": "competition_id"}, {"type": "uint64", "name": "new_status"}], "returns": {"type": "bool"}}, {"name": "update_participant_score", "args": [{"type": "uint64", "name": "competition_id"}, {"type": "uint64", "name": "startup_id"}, {"type": "uint64", "name": "new_score"}], "returns": {"type": "bool"}}, {"name": "finalize_competition", "args": [{"type": "uint64", "name": "competition_id"}, {"type": "uint64", "name": "winner_sid"}, {"type": "uint64", "name": "second_sid"}, {"type": "uint64", "name": "third_sid"}], "returns": {"type": "bool"}}, {"name": "claim_reward", "args": [{"type": "uint64", "name": "competition_id"}, {"type": "uint64", "name": "startup_id"}], "returns": {"type": "uint64"}}, {"name": "get_competition", "args": [{"type": "uint64", "name": "competition_id"}], "returns": {"type": "(string,string,uint64,uint64,uint64,uint64,uint64,uint64)"}, "readonly": true}, {"name": "get_participant", "args": [{"type": "uint64", "name": "competition_id"}, {"type": "uint64", "name": "startup_id"}], "returns": {"type": "(address,uint64,uint64,uint64,bool)"}, "readonly": true}], "state": {"global": {"num_uints": 2, "num_byte_slices": 1}, "local": {"num_uints": 0, "num_byte_slices": 0}}, "bare_actions": {"create": "CALL"}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or a dataclass for the respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class Competition:
    name: str
    description: str
    start_time: int
    end_time: int
    status: int
    total_prize_pool: int
    max_participants: int
    entry_fee: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class Participant:
    startup_owner: str
    joined_at: int
    score: int
    rank: int
    reward_claimed: bool

@dataclasses.dataclass(frozen=True, kw_only=True)
class Results:
    first_place_sid: int
    second_place_sid: int
    third_place_sid: int
    rewards_distributed: bool

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetOwnerArgs:
    new_owner: str

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateCompetitionArgs:
    name: str
    description: str
    start_time: int
    end_time: int
    prize_pool_payment: algokit_utils.Transaction
    max_participants: int
    entry_fee: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class JoinCompetitionArgs:
    competition_id: int
    startup_id: int
    entry_fee_payment: algokit_utils.Transaction

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateStatusArgs:
    competition_id: int
    new_status: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateParticipantScoreArgs:
    competition_id: int
    startup_id: int
    new_score: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class FinalizeCompetitionArgs:
    competition_id: int
    winner_sid: int
    second_sid: int
    third_sid: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class ClaimRewardArgs:
    competition_id: int
    startup_id: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetCompetitionArgs:
    competition_id: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetParticipantArgs:
    competition_id: int
    startup_id: int


class CompetitionAppClient:
    """Client for interacting with CompetitionApp smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...

    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")

    def set_owner(
        self,
        args: tuple[str] | SetOwnerArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "set_owner",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def create_competition(
        self,
        args: tuple[str, str, int, int, algokit_utils.Transaction, int, int] | CreateCompetitionArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "create_competition",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def join_competition(
        self,
        args: tuple[int, int, algokit_utils.Transaction] | JoinCompetitionArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "join_competition",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def update_status(
        self,
        args: tuple[int, int] | UpdateStatusArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "update_status",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def update_participant_score(
        self,
        args: tuple[int, int, int] | UpdateParticipantScoreArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "update_participant_score",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def finalize_competition(
        self,
        args: tuple[int, int, int, int] | FinalizeCompetitionArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "finalize_competition",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def claim_reward(
        self,
        args: tuple[int, int] | ClaimRewardArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "claim_reward",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def get_competition(
        self,
        args: tuple[int] | GetCompetitionArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Competition]:
        method_args = _parse_abi_args(args)
        response = self.app_client.call(
            "get_competition",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )
        if isinstance(response.return_value, (list, tuple)):
            response.return_value = Competition(*response.return_value)
        return response

    def get_participant(
        self,
        args: tuple[int, int] | GetParticipantArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Participant]:
        method_args = _parse_abi_args(args)
        response = self.app_client.call(
            "get_participant",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )
        if isinstance(response.return_value, (list, tuple)):
            response.return_value = Participant(*response.return_value)
        return response

