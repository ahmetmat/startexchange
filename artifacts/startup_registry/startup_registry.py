# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"name": "StartupRegistryApp", "structs": {"Startup": {"name": "Startup", "elements": [["owner", "address"], ["name", "string"], ["description", "string"], ["github_repo", "string"], ["website", "string"], ["twitter", "string"], ["token_asset_id", "uint64"], ["created_at", "uint64"], ["is_verified", "bool"], ["total_score", "uint64"], ["launchpad_app_id", "uint64"]]}}, "methods": [{"name": "set_contract_owner", "args": [{"type": "address", "name": "new_owner"}], "returns": {"type": "bool"}}, {"name": "register_startup", "args": [{"type": "string", "name": "name"}, {"type": "string", "name": "description"}, {"type": "string", "name": "github_repo"}, {"type": "string", "name": "website"}, {"type": "string", "name": "twitter"}, {"type": "uint64", "name": "token_asset_id"}], "returns": {"type": "uint64"}}, {"name": "update_startup", "args": [{"type": "uint64", "name": "startup_id"}, {"type": "string", "name": "name"}, {"type": "string", "name": "description"}, {"type": "string", "name": "website"}, {"type": "string", "name": "twitter"}], "returns": {"type": "bool"}}, {"name": "verify_startup", "args": [{"type": "uint64", "name": "startup_id"}, {"type": "bool", "name": "verified_status"}], "returns": {"type": "bool"}}, {"name": "update_score", "args": [{"type": "uint64", "name": "startup_id"}, {"type": "uint64", "name": "new_score"}], "returns": {"type": "bool"}}, {"name": "create_launchpad", "args": [{"type": "uint64", "name": "startup_id"}, {"type": "pay", "name": "payment_for_mbr"}], "returns": {"type": "uint64"}}, {"name": "get_startup", "args": [{"type": "uint64", "name": "startup_id"}], "returns": {"type": "(address,string,string,string,string,string,uint64,uint64,bool,uint64,uint64)"}, "readonly": true}, {"name": "get_next_startup_id", "args": [], "returns": {"type": "uint64"}, "readonly": true}], "state": {"global": {"num_uints": 1, "num_byte_slices": 1}, "local": {"num_uints": 0, "num_byte_slices": 0}}, "bare_actions": {"create": "NEVER"}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or a dataclass for the respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class Startup:
    """
    Dataclass for the Startup struct.
    """
    owner: str
    name: str
    description: str
    github_repo: str
    website: str
    twitter: str
    token_asset_id: int
    created_at: int
    is_verified: bool
    total_score: int
    launchpad_app_id: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetContractOwnerArgs:
    """Dataclass for set_contract_owner arguments"""
    new_owner: str

@dataclasses.dataclass(frozen=True, kw_only=True)
class RegisterStartupArgs:
    """Dataclass for register_startup arguments"""
    name: str
    description: str
    github_repo: str
    website: str
    twitter: str
    token_asset_id: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateStartupArgs:
    """Dataclass for update_startup arguments"""
    startup_id: int
    name: str
    description: str
    website: str
    twitter: str

@dataclasses.dataclass(frozen=True, kw_only=True)
class VerifyStartupArgs:
    """Dataclass for verify_startup arguments"""
    startup_id: int
    verified_status: bool

@dataclasses.dataclass(frozen=True, kw_only=True)
class UpdateScoreArgs:
    """Dataclass for update_score arguments"""
    startup_id: int
    new_score: int

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateLaunchpadArgs:
    """Dataclass for create_launchpad arguments"""
    startup_id: int
    payment_for_mbr: algokit_utils.Transaction

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetStartupArgs:
    """Dataclass for get_startup arguments"""
    startup_id: int

class StartupRegistryAppClient:
    """Client for interacting with StartupRegistryApp smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...

    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")

    def set_contract_owner(
        self,
        args: tuple[str] | SetContractOwnerArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """
        Calls the set_contract_owner method.
        
        Args:
            args: The arguments for the method call.
            transaction_parameters: Parameters for the transaction.
        
        Returns:
            The result of the transaction.
        """
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "set_contract_owner",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def register_startup(
        self,
        args: tuple[str, str, str, str, str, int] | RegisterStartupArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """
        Calls the register_startup method.
        """
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "register_startup",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def update_startup(
        self,
        args: tuple[int, str, str, str, str] | UpdateStartupArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """
        Calls the update_startup method.
        """
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "update_startup",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def verify_startup(
        self,
        args: tuple[int, bool] | VerifyStartupArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """
        Calls the verify_startup method.
        """
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "verify_startup",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def update_score(
        self,
        args: tuple[int, int] | UpdateScoreArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """
        Calls the update_score method.
        """
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "update_score",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def create_launchpad(
        self,
        args: tuple[int, algokit_utils.Transaction] | CreateLaunchpadArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """
        Calls the create_launchpad method.
        """
        method_args = _parse_abi_args(args)
        return self.app_client.call(
            "create_launchpad",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )

    def get_startup(
        self,
        args: tuple[int] | GetStartupArgs,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Startup]:
        """
        Calls the get_startup method.
        """
        method_args = _parse_abi_args(args)
        response = self.app_client.call(
            "get_startup",
            args=method_args,
            transaction_parameters=transaction_parameters,
        )
        # Manually parse the tuple into the Startup dataclass
        if isinstance(response.return_value, (list, tuple)):
            response.return_value = Startup(*response.return_value)
        return response


    def get_next_startup_id(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """
        Calls the get_next_startup_id method.
        """
        return self.app_client.call(
            "get_next_startup_id",
            transaction_parameters=transaction_parameters,
        )
